입력 크기에 비례하는 비를 쓰기 때문에 이제 제자리성 정렬이 아닙니다. 
안정성은 얘는 안정된 정렬이에요. 순서대로 뒤쪽 레코드로부터 가장 뒤쪽에 배치를 하고 있죠 같은 수가 나왔을 때 바로 뒤에다가 왜냐하면 제일 있을 수 있는 최대의 인덱스를 우리가 보잖아요. 
그렇기 때문에 당연히 안정성을 보장을 받을 수가 있습니다. 
그래서 지금 봤듯이 이 분포를 기반으로 한 정렬들은
빠르기는 빠른데요. 이제 특정한 경우에만 어썸션이 있습니다. 
사용을 할 수 있는 가정이 있습니다. 
두 번째 기수 정렬을 해볼게요 전체 키를 여러 자리로 나누어서 각 자리마다 개수 정렬과 같은 안정적인 정렬 알고리즘을 안정적인 정렬 알고리즘 괴수 정렬 삽입 정렬 합병 정렬 등을 적용해서 정렬하는 방법이에요.
이 안정성이 왜 중요하냐고 저번에 질문한 학생이 있었는데 여기서도 한 가지가 있을 것 같아요. 
안정적인 정열을 여기는 정렬 안의 정열을 사용을 하거든요. 
그래서 안정적인 정렬을 근데 꼭 사용해야 되는 예입니다. 
얘가 그래서 그것도 한 가지 안정성이 왜 필요한지 그걸 왜 따지는지에 대답이 하나 될 수 있을 것 같아서
잠깐 이야기를 해주는데 일단 무슨 소리인지 지금 못 알아들을 텐데 일단 이거 설명을 하고 이야기를 할게요 낮에 자리부터 순차적으로 정렬을 한대요 어떻게 됐냐면 여러분한테 이런 애들이 들어왔어요. 
이런 애들이 들어왔을 때 낮은 자리부터 먼저 정리를 하는 거예요. 
7 4 4 7 0 1 0 하면 하면 일단
여기 0이 제일 작죠 그러니까 830을 앞으로 뽑아요. 
그다음에는 뭐가 작아요. 1이 작죠. 
그러니까 911이 여기 제일 마지막 자릿수를 정렬하는 거예요. 
0 1 4 4
오
7 7 이렇게 되도록 마지막 자리 수를 가지고 정렬을 하는 거예요. 
그다음에 두 번째 자리를 가지고 하겠죠. 
3 1 5 2 5 6 5 하면 어떻게 돼야 돼요 1 2 3 5가 두 개 있네 색이 있구나 색이나 있어요. 
어떻게 여기 지금 갔지 누구를 앞에다 넣어야 돼
안정적인 정렬을 사용해서 정렬을 하는 거예요. 
그렇지 않으면 어떻게 되겠어요. 지금 제 뒤에 거 가지고 지금 정렬이 돼 있어요. 
사하고 5하고 그 다음에 7 4 5 7 순서가 되도록 지금 어떤 건지 감이 와요. 
5 숫자가 같기는 같지만 지금 얘가 앞에 있었으면 얘를 앞에 누는 거예요.
얘가 그다음에 있었으면 그다음에 넣고 얘가 그다음에 있었으면 그다음에 넣고 여기서 여기로 이제 여기서도 그렇고 처음에는 크게 상관없지만 두 번째도 그렇고 그다음에도 그렇고 얘를 이제 낮은 자리를 가지고 정렬을 하는데 정렬은 아무 정렬이나 써도 돼요. 
안정적인 거 써야 돼요 근데 왜
이렇게 5가 3개 나왔을 경우에 얘네끼리 순서로 바꿔버리면 안 되니까 여기 가면 조금 더 이해가 갈 거예요. 
그다음에는 이제 높은 자리 제일 높은 자리가 여기 전 3인데 얘를 가지고 정렬을 해보면 얘를 가지고 정렬을 좀 해보면 9 1 8 6 이렇게 되면 어떻게 돼요. 
5 4 5가 되잖아요. 얘가 제일 작으니까 얘부터 와야 되겠죠. 
1서부터 그런데 두 번째 사 사가 작으니까 사도 오는 것도 문제없어요.
그런데 오는 어떻게 돼요. 지금 두 개가 있어요. 
여기 얘도 있고 얘도 있어 그러면 얘를 앞에다 놓고 그다음에 얘를 넣으면 우리가 안정적인 정열을 사용하게 되면 이렇게 되죠. 
근데 우리가 안정적이지 않은 정열을 사용하면 잘못하면 얘네들이가 순서가 바뀌어버려요. 
567이 앞에 나오고 그다음에 555가 나와요 돼요 안돼요 그럼 정렬이 안 되죠
무슨 소리인지 알겠어요. 이럴 때 이제 안정적인 정열을 이용을 해서 각 단계를 정렬을 해나가는 게 필요합니다. 
이게 안정적인 정열을 우리가 왜 따지는지에 한 가지 답이 될 수 있을 것 같습니다. 
그래서 어떻게 하는 건지 알겠죠. 가장 낮은 자리에 맞춰서 정리를 해놓고 그다음에 두 번째 자리에 맞춰서 정 해놓고 그다음에 마지막에 제일 높은 자리 왜냐하면 우리 제일 높은 자리가 제일 중요하잖아요. 
그렇죠
그래서 그렇게 정렬을 하게 됩니다. 이게 기수 정렬이고요 얘는 제자리 정렬은 아니에요. 
진법의 크기만큼 메모리가 추가가 돼요. 
그래서 경우에 따라 데이터 크기만큼 메모리가 추가가 되기 때문에 제자리 정렬이 아니고요 얘는 안정적인 정렬이에요. 
순서대로 뒤쪽 레코드부터 장 뒤쪽에 배치를 하게 되기 때문에 이제 안정적인 정맥이 됩니다.
개수 정렬은 오엔이 걸려요. 이용시 체약 시간 복잡도는 5dn이 됩니다. 
d는 여기서 자리 개수를 이야기를 하고요 d를 이제 그냥 우리가 상수라고 생각을 하면 별로 많지 않다고 생각을 하면 자리 수가 그러면 그냥 on이라고 하면 됩니다. 
왜냐하면 우리 지금 ng씩 정렬을 시키잖아요.
그래서 네 근데 만약에 여러분들이 계수 정렬을 이용을 하지 않게 되고 각 단계에서 정렬을 더 시간이 오래 걸리는 걸 하면 거기에 맞춰서 커지겠죠. 
그래서 이거는 중간 단계 정렬을 어떤 거를 사용하느냐에서 틀리겠지만 개수 정렬을 사용하게 될 경우에는
최약 시간 복잡도가 5n 정도 된다고 보면 될 것 같습니다. 
버켓 정렬은 개수 정렬을 일반화한 거예요. 
가정은 뭐냐면 입력 키 값이 특정한 작은 범위 내에서만 변화하는 경우를 생각합니다. 
키 값이 경우가 아까 한 거랑 비슷하게 이제 어떤 범위 내에 있다고 생각을 합시다 입력된 그리고 한 가지 더 있는데
키 값이 범위가 일정한 안에 있고 입력 키 값이 해당 범위 내에서 확률적으로 균등하게 분포가 돼 있다고 하는데 이게 무슨 말인지 기회를 보면서 이야기를 해줄게요 버켓 정렬은 이제 어떤 버켓을 생각하면 되는데 키 값이 0과 1 사이에 만약에 균일하게 분포한다고 가정을 해봅시다
즉 하나의 버킷에는 하나의 키만이 들어있을 확률이 높고 만약 한 버킷에 여러 키가 들어간다면 같은 버킷에 속하는 키끼리 삽입 정렬 같은 간단한 정렬 알고리즘 할 수가 있어요. 
버기 순서에 따라서 이제 데이터를 출력을 하게 됩니다.
편의상의 키 값이 0하고 1 사이에 있다고 가정을 하고요 n개의 키가 있다고 하면 이제 구간 0에서 1 사이를 n 등분하고 이들 각각을 하나의 버켓으로 생각을 해요. 
a가 만약에 인풋이 086 0 3 2 2 7 1 2 4 9 2 이렇게 쭉 들어왔다고 하면 여기다 넣는 거예요.
어떻게 균일하게 분포가 돼 있다고 하면 어떻게 들어갈까요. 
일단 086은 여기 여덟 번째 버켓에다 집어넣고 032는 여기에다가 집어넣고 0 27은 여기다 집어넣고 그다음에 쭉 넣다 보면 02일이 또 나왔어요. 
그러면 여기 들어가게 되죠. 근데 지금 균일하게 있다고 이야기를 했잖아요. 
균일하게 분포를 한다고 하면 어떻게 되겠어요. 
얘가 한쪽이 막 몰려 있겠어요.
골고루 이렇게 퍼져 있겠죠. 쭉 이렇게 퍼져 있게 될 거예요. 
이렇게 그렇죠 이렇게 들어가게 한 다음에 그다음에 만약에 이렇게 겹친 애들이 있잖아요. 
한 버켓에 들어간 애들이 있으면 간단한 이제 많지 않을 테니까 균질하게 퍼질 거니까 얘네들을 이제 삽입 정렬 같은 간단한 정렬 알고리즘을 아니면 여기 쭉 이렇게 여러 개씩 들어가 있을 수도 있지만 아무튼 균일하게 들어가 있다는 소리예요.
삽입 정열 같은 이제 간단한 정렬 알고리즘을 이용을 해서 0.21 그다음에 0.27이 되게 바꾸는 거예요. 
얘 같은 경우에도 0 86 8 9 8 7이 됐으면 8 6 8 7 8 9 이렇게 정렬을 하는 거죠. 
그다음에는 어떻게 하면 돼요 그냥 순서대로 복귀 순서에 따라 데이터를 그냥 출력하면 됩니다.
그래서 이것도 지금 코드를 집어넣어놨고요 어렵지 않으니까 여러분들이 한번 보세요. 
리스트에다가 삽입을 하고 정렬 삽입 정렬을 위해서 각각 리스트에 있는 애들을 정렬을 하고 말로 많이 써놨네요. 
여러분들이 코딩은 하면 될 것 같은데 각각 버켓을 정렬을 한 다음에 쭉 출력을 하면 됩니다.
시간 복잡도는 이제 네 번째 줄을 제외하고는 모두 5엔 사이에 가능하다고 하고요 삽입 정렬하는 부분 만약에 같은 버켓에 많이 들어 있다고 하면 여기 삽입 정렬 꼭 안 써도 돼요. 
어떤 정렬을 쓰든 간에 아무튼 그 정렬에 의해서 시간이 좀 늘어날 수는 있겠지만 그걸 제외하고는 모두 5n 사이가 되고요 평균 시간 복잡도는 오n이 됩니다. 
입력 레코드가 균등하게 분포된 경우 각 버킷에서 삽입 병렬은 그냥 평균 상수 시간 이내에 가능하다고 생각을 하는 거예요. 
많지가 않으니까 그냥 상수라고 그냥
무시를 하게 되면 이렇게 되고요 최약 시간 복잡도는 어떻게 되겠어요. 
입력 레코드가 균등하게 분포가 별로 안 돼 있는 거예요. 
그래서 한 곳에만 몰리게 되면 어떻게 보면 한 버킷에 다 들어가 보게 되면 삽입 정렬 시간 복잡도가 동일해져버리게 되죠. 
그래서 사실은
이거는 우리가 생각하는 데이터의 가정하고 맞지가 않아요. 
이런 경우에는 할 수는 있는데 삽입 정렬하는 거랑 같아져 버리기 때문에 이제 최악이 되겠죠. 
제자리성은 이제 제자리 정렬은 아니에요. 
입력 레코드를 재배치하기 위한 별도의 공간을 사용을 하고 있고요
얘는 안정된 정렬입니다. 삽입 정렬에 기반을 하고 있기 때문에 이제 안정적인 정렬이 가능하다 합니다. 
그래서 여기까지 하겠습니다.